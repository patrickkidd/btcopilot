# SARF Ground Truth Coding System - Technical Reference

**Document Purpose**: Technical reference for Claude Code when modifying the btcopilot training app's ground truth coding workflow.

**Last Updated**: 2025-11-10

---

## Table of Contents

1. [Overview](#overview)
2. [Data Flow Architecture](#1-data-flow-architecture)
   - [AI Extraction Storage (Statement.pdp_deltas)](#11-ai-extraction-storage-statementpdp_deltas)
   - [Auditor Corrections (Feedback.edited_extraction)](#12-auditor-corrections-feedbackedited_extraction)
   - [Approval State Machine](#13-approval-state-machine)
   - [Cumulative Calculation (pdp.cumulative())](#14-cumulative-calculation-pdpcumulative)
   - [Export Pipeline](#15-export-pipeline)
3. [SARF-Specific Schema](#2-sarf-specific-schema)
   - [Event Object Structure](#21-event-object-structure)
   - [VariableShift Enum](#22-variableshift-enum)
   - [RelationshipKind Enum](#23-relationshipkind-enum)
   - [Confidence Scoring](#24-confidence-scoring)
4. [UI Component Architecture](#3-ui-component-architecture)
   - [Main Component: extracted_data_display.html](#31-main-component-extracted_data_displayhtml)
   - [Inline Editing Pattern](#32-inline-editing-pattern)
   - [Discussion Audit Page Architecture](#33-discussion-audit-page-architecture)
   - [Tab System (Admin Only)](#34-tab-system-admin-only)
   - [Approval Button Logic](#35-approval-button-logic)
5. [API Endpoints](#4-api-endpoints)
   - [Feedback Submission](#41-feedback-submission)
   - [Approval Routes](#42-approval-routes)
   - [Export Route](#43-export-route)
   - [Speaker Mapping](#44-speaker-mapping)
6. [Critical Business Logic](#5-critical-business-logic)
   - [Why Only One Approval Per Statement](#51-why-only-one-approval-per-statement)
   - [How Deletes Work in Ground Truth Coding](#52-how-deletes-work-in-ground-truth-coding)
   - [PDPDeltas Merge Logic: cumulative() vs apply_deltas()](#53-pdpdeltas-merge-logic-cumulative-vs-apply_deltas)
   - [Test Case Export Format](#54-test-case-export-format)
7. [File Organization](#6-file-organization)
   - [Key Files in btcopilot/training/](#61-key-files-in-btcopilottraining)
   - [Templates](#62-templates)
   - [Shared Schema with btcopilot/personal](#63-shared-schema-with-btcopilotpersonal)
   - [Test Case Export Directory](#64-test-case-export-directory)
8. [Design Patterns & Gotchas](#7-design-patterns--gotchas)
9. [Testing Considerations](#8-testing-considerations)
10. [Migration Path for Schema Changes](#9-migration-path-for-schema-changes)
11. [Related Documentation](#10-related-documentation)
12. [Appendix: Quick Reference Tables](#appendix-quick-reference-tables)

---

## Overview

The SARF (Symptom, Anxiety, Relationship, Functioning) ground truth coding system in `btcopilot/training` is a dual-purpose system that:

1. **Collects expert feedback** on AI-generated SARF extractions from therapy session transcripts
2. **Manages approval workflows** to create ground truth test cases for model training and evaluation

This document provides technical implementation details for future code modifications.

**Scope Note**: This document focuses on the ground truth coding workflow AFTER data has been generated. It does NOT cover how discussions are created, which happens via:
- **Personal app**: Real-time chat conversations between users and AI
- **Training app**: AI-transcribed audio recordings of clinical interviews imported for expert review

For discussion creation workflows, see [DATA_MODEL_FLOW.md](./DATA_MODEL_FLOW.md) sections on chat flow and statement models.

---

## 1. Data Flow Architecture

### 1.1 AI Extraction Storage (`Statement.pdp_deltas`)

**Model**: [btcopilot/personal/models/statement.py](../btcopilot/personal/models/statement.py)

**Column**: `pdp_deltas` (JSON)

**Schema**: Stores `PDPDeltas` structure from [btcopilot/schema.py](../btcopilot/schema.py)
```python
pdp_deltas = {
    "people": [Person, ...],       # List of Person objects
    "events": [Event, ...],         # List of Event objects with SARF variables
    "pair_bonds": [PairBond, ...],  # List of PairBond objects (parent pairs)
    "delete": [int, ...]            # IDs to delete from PDP
}
```

**Source**: Generated by AI model via `btcopilot.pdp.update()` which:
- Takes conversation history + current PDP state
- Returns PDPDeltas containing ONLY new/changed data (sparse deltas)
- Uses negative IDs for all PDP items (positive IDs are committed diagram items)

**CRITICAL**: `pdp_deltas` stores DELTAS, not full state. To get cumulative state, use `pdp.cumulative()`.

---

### 1.2 Auditor Corrections (`Feedback.edited_extraction`)

**Model**: [btcopilot/training/models.py](../btcopilot/training/models.py)

**Column**: `edited_extraction` (JSON)

**Schema**: Complete corrected extraction (same structure as `pdp_deltas`)
```python
edited_extraction = {
    "people": [...],
    "events": [...],
    "pair_bonds": [...],
    "delete": [...]
}
```

**Source**: Submitted via `POST /training/feedback/` from inline editing in UI

**Key Differences from pdp_deltas**:
- **Complete replacement**: Contains full corrected extraction, not just changes from AI version
- **Multiple submissions possible**: One `Feedback` record per auditor per statement
- **Upsert behavior**: Backend upserts based on `(statement_id, auditor_id, feedback_type)` composite key

---

### 1.3 Approval State Machine

**CRITICAL RULE**: For any given statement, EITHER the AI extraction OR one auditor correction can be approved, never both.

**Models Involved**:
- `Statement.approved` - AI extraction approval flag
- `Feedback.approved` - Auditor correction approval flag

**Enforcement Location**: [btcopilot/training/routes/admin.py](../btcopilot/training/routes/admin.py)

**When Approving AI Extraction** (lines 780-800):
```python
def approve_statement(statement_id):
    # Step 1: Unapprove ALL approved feedback for this statement
    approved_feedback = Feedback.query.filter(
        Feedback.statement_id == statement_id,
        Feedback.feedback_type == "extraction",
        Feedback.approved == True
    ).all()

    for feedback in approved_feedback:
        feedback.approved = False
        feedback.approved_by = None
        feedback.approved_at = None

    # Step 2: Approve the statement
    statement.approved = True
    statement.approved_by = current_user.username
    statement.approved_at = datetime.utcnow()
    db.session.commit()
```

**When Approving Auditor Correction** (lines 850-880):
```python
def quick_approve(feedback_id):
    # Step 1: Unapprove the statement itself
    feedback.statement.approved = False
    feedback.statement.approved_by = None
    feedback.statement.approved_at = None

    # Step 2: Unapprove ALL other feedback for this statement
    other_feedback = Feedback.query.filter(
        Feedback.statement_id == feedback.statement_id,
        Feedback.id != feedback_id,
        Feedback.approved == True
    ).all()

    for other in other_feedback:
        other.approved = False
        other.approved_by = None
        other.approved_at = None

    # Step 3: Approve this feedback
    feedback.approved = True
    feedback.approved_by = current_user.username
    feedback.approved_at = datetime.utcnow()
    db.session.commit()
```

**Authorization**: Only `ROLE_ADMIN` users can approve

**Approval Metadata Fields**:
```python
approved: bool          # Approval flag
approved_by: str        # Username of approver
approved_at: DateTime   # Timestamp of approval
exported_at: DateTime   # When exported as test case (prevents re-export)
```

---

### 1.4 Cumulative Calculation (`pdp.cumulative()`)

**Location**: [btcopilot/pdp.py:134](../btcopilot/pdp.py)

**Purpose**: Build running totals of all approved extractions UP TO a given statement

**Algorithm**:
```python
def cumulative(discussion: Discussion, up_to_statement: Statement) -> PDP:
    """
    Returns accumulated PDP state from all statements before the target.
    Used for display context when auditing a statement.
    """
    cumulative_pdp = PDP()

    # Sort statements chronologically
    sorted_statements = sorted(
        discussion.statements,
        key=lambda s: (s.order or 0, s.id)
    )

    # Accumulate all prior statements
    # NOTE: stmt.pdp_deltas is a JSON column, so it's always dicts (never dataclass instances)
    for stmt in sorted_statements:
        if stmt.id < up_to_statement.id and stmt.pdp_deltas:
            if "people" in stmt.pdp_deltas:
                for person_data in stmt.pdp_deltas["people"]:
                    cumulative_pdp.people.append(Person(**person_data))

            if "events" in stmt.pdp_deltas:
                for event_data in stmt.pdp_deltas["events"]:
                    cumulative_pdp.events.append(Event(**event_data))

            if "pair_bonds" in stmt.pdp_deltas:
                for pair_bond_data in stmt.pdp_deltas["pair_bonds"]:
                    cumulative_pdp.pair_bonds.append(PairBond(**pair_bond_data))

    return cumulative_pdp
```

**Key Behaviors**:
- Only includes statements with `id < up_to_statement.id`
- Sorts by `order` column then `id` for reliable chronological ordering
- **Does NOT apply deletes** - only accumulates additions
- **Does NOT deduplicate** - may contain duplicate IDs if re-extracted
- Returns `PDP` object (not `PDPDeltas`)
- Handles missing keys (`people`, `events`, `pair_bonds`) for backward compatibility
- Uses defensive type checking with `isinstance()` to handle both dict and object forms

**Usage**: Displayed in UI as "Cumulative Notes" column, shows "what the AI knew" at that point in the conversation

**GOTCHA**: This is NOT the same as `apply_deltas()`. See section 5.3 for critical differences.

---

### 1.5 Export Pipeline

**Entry Point**: [btcopilot/training/export_tests.py](../btcopilot/training/export_tests.py)

**Target Directory**: `./model_tests/data/uncategorized/` (relative to repo root)

**Two Export Paths**:

#### Path 1: AI Extraction Export (if `Statement.approved == True`)

**File Name**: `stmt_{statement_id}.json`

**Structure**:
```json
{
  "test_id": "stmt_123",
  "source": "statement",
  "statement_id": 123,
  "inputs": {
    "conversation_history": [
      {"speaker": "Subject", "text": "..."},
      {"speaker": "Expert", "text": "..."}
    ],
    "database": {
      "people": [...],
      "events": [...],
      "pdp": {"people": [], "events": []},
      "lastItemId": 2
    },
    "current_pdp": {
      "people": [...],
      "events": [...]
    },
    "user_statement": "I felt anxious when mom called yesterday",
    "custom_prompts": {...}
  },
  "expected_output": {
    "people": [],
    "events": [{...}],
    "delete": []
  }
}
```

#### Path 2: Auditor Correction Export (if `Feedback.approved == True`)

**File Name**: `stmt_{statement_id}_corrected.json`

**Structure**: Same as Path 1, plus:
```json
{
  ...
  "feedback_id": 456,
  "auditor_id": "john.doe@example.com",
  "original_output": {
    "people": [...],
    "events": [...],
    "delete": [...]
  },
  "feedback_comment": "Corrected relationship type from conflict to distance"
}
```

**Mutual Exclusivity During Export** (export_tests.py:42-58):
```python
# When exporting approved statements:
for statement in approved_statements:
    # Check if approved feedback exists for this statement
    approved_feedback = Feedback.query.filter(
        Feedback.statement_id == statement.id,
        Feedback.approved == True,
        Feedback.feedback_type == "extraction"
    ).first()

    if approved_feedback:
        # Mark statement as exported but DON'T create file
        statement.exported_at = datetime.utcnow()
        continue

    # Otherwise export the AI version
    create_statement_test_case(statement)
    statement.exported_at = datetime.utcnow()
```

**Export Idempotency**: `exported_at` field prevents re-exporting. Once exported, item is skipped on subsequent runs.

**Test Harness Usage**:
1. Load JSON file
2. Pass `inputs` to model
3. Compare model output to `expected_output`
4. Calculate precision/recall/F1 for SARF variables

---

## 2. SARF-Specific Schema

### 2.0 Person Object Structure

**Location**: [btcopilot/schema.py:190-197](../btcopilot/schema.py)

```python
@dataclass
class Person:
    id: int | None = None
    name: str | None = None
    last_name: str | None = None
    parents: int | None = None  # Reference to PairBond object (parents)
    confidence: float | None = None
```

#### **Relationship Schema**

**Parent relationships** (via PairBond):
- `parents` - References a `PairBond` object that contains both parent IDs
- Validated by pdp.py (must be negative ID if present, or positive for committed pairs)
- See PairBond Object Structure below for details

**Spouse relationships**:
- Inferred from PairBond entries and Events
- No direct spouse list stored on Person

**Child relationships**:
- Not stored directly - inferred from other People's `parents` references

**AI Training**: Prompt examples in personal/prompts.py train the LLM to create PairBond objects for parent pairs.

### 2.0.1 PairBond Object Structure

**Location**: [btcopilot/schema.py:182-187](../btcopilot/schema.py)

```python
@dataclass
class PairBond:
    id: int | None = None
    person_a_id: int | None = None  # First parent
    person_b_id: int | None = None  # Second parent
    confidence: float | None = None
```

**Purpose**: Represents an actual or potential human reproductive pair in
biology (biological mother/father) as a single reusable entity.

**Key Points**:
- `person_a_id` and `person_b_id` reference Person objects (either PDP or committed)
- Multiple children can reference the same PairBond via `Person.pair_bond_id`
- Validated by pdp.py to ensure both parent references exist
- Uses negative IDs for PDP items (uncommitted), positive for committed pairs

**Usage Pattern**:
```python
# Create a pair bond for parents
pair_bond = PairBond(id=-1, person_a_id=-2, person_b_id=-3, confidence=0.95)

# Child references the pair bond
child = Person(id=-4, name="Alice", pair_bond_id=-1, confidence=0.9)
```

---

### 2.1 Event Object Structure

**Location**: [btcopilot/schema.py:200](../btcopilot/schema.py)

```python
@dataclass
class Event:
    id: int
    kind: EventKind
    person: int | None = None
    spouse: int | None = None
    child: int | None = None
    description: str | None = None
    dateTime: str | None = None
    endDateTime: str | None = None

    # THE FOUR SARF VARIABLES:
    symptom: VariableShift | None = None
    anxiety: VariableShift | None = None
    relationship: RelationshipKind | None = None
    functioning: VariableShift | None = None

    # Relationship metadata:
    relationshipTargets: list[int] = field(default_factory=list)
    relationshipTriangles: list[int] = field(default_factory=list)

    # PDP-specific:
    confidence: float | None = None  # AI confidence (0.0-1.0)
```

**Key Points**:
- Each event can have 0-4 SARF variables coded
- `symptom`, `anxiety`, `functioning` use `VariableShift` enum
- `relationship` uses `RelationshipKind` enum
- `confidence` only present in PDP items (AI extractions), set to 1.0 for committed items

**EventKind Enum** (schema.py:100):
```python
class EventKind(enum.Enum):
    Bonded = "bonded"
    Married = "married"
    Birth = "birth"
    Adopted = "adopted"
    Moved = "moved"
    Separated = "separated"
    Divorced = "divorced"
    Shift = "shift"          # Generic state change - most common for SARF events
    Death = "death"
```

---

### 2.2 VariableShift Enum

**Location**: [btcopilot/schema.py:194](../btcopilot/schema.py)

```python
class VariableShift(enum.StrEnum):
    Up = "up"
    Down = "down"
    Same = "same"
```

**Usage**: Codes directional change in symptom/anxiety/functioning

**UI Representation**: Color-coded in [therapist_base.html](../btcopilot/training/templates/therapist_base.html)
```css
.shift-up { background-color: #ffeb3b; }     /* Yellow */
.shift-down { background-color: #f44336; }   /* Red */
.shift-same { background-color: #9e9e9e; }   /* Grey */
```

**Semantic Notes**:
- "Up" can mean worsening (symptoms, anxiety) or improvement (functioning)
- Clinical interpretation depends on which variable is being coded
- Domain experts should be trained on consistent coding practices

---

### 2.3 RelationshipKind Enum

**Location**: [btcopilot/schema.py:149](../btcopilot/schema.py)

```python
class RelationshipKind(enum.Enum):
    Fusion = "fusion"
    Conflict = "conflict"
    Distance = "distance"
    Overfunctioning = "overfunctioning"
    Underfunctioning = "underfunctioning"
    Projection = "projection"
    DefinedSelf = "defined-self"
    Toward = "toward"
    Away = "away"
    Inside = "inside"
    Outside = "outside"
    Cutoff = "cutoff"
```

**Two Relationship Patterns**:

#### 1. Dyadic Relationships (most kinds)
Uses `relationshipTargets` list containing person IDs involved in the relationship.

**Example**:
```python
Event(
    kind=EventKind.Shift,
    person=1,
    relationship=RelationshipKind.Conflict,
    relationshipTargets=[2, 3],  # Conflict between person 1 and persons 2 & 3
    description="Argued with mom and sister about holiday plans"
)
```

#### 2. Triangles (`Inside`/`Outside`)
Uses `relationshipTriangles` list containing tuples of (inside_person, inside_person) pairs.

**Example**:
```python
Event(
    kind=EventKind.Shift,
    person=1,  # The person experiencing the triangle position
    relationship=RelationshipKind.Inside,
    relationshipTriangles=[(2, 3)],  # Persons 2 & 3 are the other inside positions
    description="Mom and I aligned against dad's decision"
)
```

**Validation** ([btcopilot/pdp.py:93-103](../btcopilot/pdp.py)):
```python
# Validates all person references exist in PDP or diagram
for target in event.relationshipTargets:
    if target < 0 and target not in all_pdp_person_ids:
        errors.append(f"Event {event.id} references non-existent PDP relationship target {target}")

for person_id in event.relationshipTriangles:
    if person_id < 0 and person_id not in all_pdp_person_ids:
        errors.append(f"Event {event.id} references non-existent PDP person {person_id} in triangle")
```

**LIMITATION**: Validation only checks ID existence, not semantic correctness of relationship coding.

---

### 2.4 Confidence Scoring

**In AI Extraction** (`Statement.pdp_deltas`):
- Contains `confidence` field (0.0-1.0) on Person and Event objects
- Generated by LLM based on extraction certainty
- Lower confidence → more likely to need correction

**In Ground Truth** (`Feedback.edited_extraction`):
- May or may not have confidence values
- Auditors can edit confidence if present
- Not used in model training (ground truth is assumed 1.0 confidence)

**UI Display** ([extracted_data_display.html:323](../btcopilot/training/templates/components/extracted_data_display.html)):
```html
<small>
    Confidence:
    <span x-text="((person.confidence || 0.5) * 100).toFixed(0) + '%'"></span>
</small>
```

**Default**: If missing, UI defaults to 0.5 (50%)

---

## 3. UI Component Architecture

### 3.1 Main Component: extracted_data_display.html

**Location**: [btcopilot/training/templates/components/extracted_data_display.html](../btcopilot/training/templates/components/extracted_data_display.html)

**Size**: 1000+ lines of Alpine.js + Jinja2

**Component Function**: `componentExtractedDataWithReview()` (defined in [discussion_audit.html:1533](../btcopilot/training/templates/discussion_audit.html))

**Key State Variables**:
```javascript
{
    // Original AI extraction (immutable reference)
    originalExtractedData: extractedData,

    // Current working copy (editable)
    extractedData: {...},

    // All auditor feedback for this statement
    allFeedback: [...],

    // Tab selection
    selectedIndex: -1,  // -1 = AI tab, 0+ = auditor tab index
    selectedFeedback: null,

    // Approval state
    approved: false,
    approvedBy: null,
    approvedAt: null,

    // Inline editing state
    editingField: null,
    editingValue: null,
    hoveredField: null,

    // Person lookup cache invalidation
    personDataVersion: 0  // Incremented to force re-render of person names
}
```

**Computed Property - Current Display Data**:
```javascript
get currentDisplayData() {
    if (this.selectedIndex === -1) {
        return this.originalExtractedData;  // AI tab
    } else if (this.selectedIndex >= 0 && this.allFeedback[this.selectedIndex]) {
        return this.allFeedback[this.selectedIndex].edited_extraction || this.originalExtractedData;
    }
    return this.originalExtractedData;
}
```

**Display Modes**:
- **Collapsed**: Shows summary (person count, event count, shift indicators)
- **Expanded**: Shows full extraction with inline editing (click header to toggle)
- **Tabs** (admin only): Switch between AI extraction and auditor corrections

---

### 3.2 Inline Editing Pattern

**Hover-to-Edit** (lines 260-297):
```html
<strong class="editable-field person-name"
        @mouseenter="hoveredField = 'person-' + index + '-name'"
        @mouseleave="hoveredField = null"
        @click.stop="startEdit('person-' + index + '-name', person.name || 'Unnamed')">

    <!-- Display mode -->
    <span x-show="!isEditing('person-' + index + '-name')"
          x-text="person.name || 'Unnamed'"></span>

    <!-- Edit mode -->
    <input x-show="isEditing('person-' + index + '-name')"
           :value="editingValue"
           @input="editingValue = $event.target.value"
           @blur="savePersonName(index, $event.target.value)"
           @keydown.enter="savePersonName(index, $event.target.value); $event.target.blur()"
           @keydown.escape="cancelEdit(); $event.target.blur()"
           class="inline-edit-input"
           type="text">
</strong>
```

**Edit Flow**:
1. Hover → pencil icon appears (via CSS `.editable-field::after`)
2. Click → enter edit mode (show input, hide display)
3. Edit text
4. Blur/Enter → save to backend, update local state
5. Escape → cancel edit, revert to original value

**Save Logic**:
```javascript
savePersonName(index, newName) {
    this.extractedData.people[index].name = newName;
    this.submitFeedback();  // Upserts entire extraction to backend
    this.cancelEdit();
}
```

**IMPORTANT**: Every edit triggers full extraction submission (upsert), not just the changed field.

---

### 3.3 Conditional Field Visibility

**EventKind-Based Conditionals** ([extracted_data_display.html:488-512, 625](../btcopilot/training/templates/components/extracted_data_display.html)):

The SARF editor conditionally shows/hides event fields based on `EventKind`:

**Description Field** (shift events only):
```html
<div class="event-description" x-show="!event.kind || event.kind === 'shift'">
    {% if editable_mode %}
    <strong class="editable-field event-description"...>
        <span x-show="!isEditing(...)" x-text="event.description || 'No description'"></span>
        ...
    </strong>
    {% else %}
    <span x-text="event.description || 'No description'"></span>
    {% endif %}
</div>
```

**SARF Variables** (shift events only):
```html
<div class="variables-compact" x-show="!event.kind || event.kind === 'shift'">
    <!-- Symptom, Anxiety, Relationship, Functioning -->
</div>
```

**EventKind Selector** ([extracted_data_display.html:550-587](../btcopilot/training/templates/components/extracted_data_display.html)):
```html
<span class="event-kind-indicator editable-field"
      @click.stop="startEditEventKind('event-' + index + '-kind', event.kind)">
    <span x-show="!isEditing('event-' + index + '-kind')" x-text="event.kind || 'shift'"></span>
    <select x-show="isEditing('event-' + index + '-kind')" ...>
        <option value="shift">shift</option>
        <option value="birth">birth</option>
        <option value="adopted">adopted</option>
        <option value="bonded">bonded</option>
        <option value="married">married</option>
        <option value="separated">separated</option>
        <option value="divorced">divorced</option>
        <option value="moved">moved</option>
        <option value="death">death</option>
    </select>
</span>
```

**Visibility Rules**:
- **Description**: Only shown for `shift` events (or when `kind` is `null`/missing, defaults to shift)
- **SARF Variables (S/A/R/F)**: Only shown for `shift` events
- **Person/DateTime**: Always shown for all event kinds
- **Default Kind**: If `event.kind` is missing/null, UI defaults to `'shift'` behavior

**Styling**: EventKind indicator styled to match relationship indicators (`.shift-indicator` pattern):
- `padding: 2px 8px`
- `border-radius: 3px`
- `min-width: 50px`
- `font-size: 0.75rem`
- Neutral gray background (no color judgments for kind values)

**Field Order** (matches EventForm.qml from desktop app):
1. Person
2. Event Kind
3. Description (conditional)
4. Date/Time
5. Variables (conditional)

---

### 3.4 Discussion Audit Page Architecture

**File**: [btcopilot/training/templates/discussion_audit.html](../btcopilot/training/templates/discussion_audit.html)

**Route**: `GET /training/discussions/<discussion_id>` ([discussions.py:661](../btcopilot/training/routes/discussions.py))

**Purpose**: Three-column layout for auditing therapy session discussions and reviewing SARF extractions.

#### Three-Column Layout

**Structure**:
```html
<table class="table is-fullwidth discussion-table">
  <thead>
    <tr>
      <th>Conversational Flow</th>
      <th>Changes to Notes</th>
      <th>Cumulative Notes</th>
    </tr>
  </thead>
  <tbody>
    {% for item in statements_with_feedback %}
      <tr>
        <td><!-- Message text --></td>
        <td><!-- SARF editor --></td>
        <td><!-- Cumulative display --></td>
      </tr>
    {% endfor %}
  </tbody>
</table>
```

**Column 1: Conversational Flow**
- Read-only message display
- Shows speaker name, timestamp, message text
- For Subject (user) messages: Links to columns 2 & 3

**Column 2: Changes to Notes (SARF Editor)**
- Embeds `extracted_data_display.html` component
- Uses `item.pdp_deltas` as data source
- Editable mode for auditors
- Shows AI extraction or auditor corrections (tabs for admins)
- **Variable**: `data = item.pdp_deltas`

**Column 3: Cumulative Notes**
- Embeds same `extracted_data_display.html` component
- Uses `item.cumulative_pdp` as data source
- **Read-only mode** (`editable_mode = false`)
- Collapsed by default (`collapsed = true`)
- Synchronized expand/collapse with column 2
- **Variable**: `data = item.cumulative_pdp`

#### Cumulative Calculation (Server-Side)

**Location**: [discussions.py:678-796](../btcopilot/training/routes/discussions.py)

**Algorithm** (in `audit()` route):
```python
# Initialize empty PDP state
cumulative_pdp_state = PDP(people=[], events=[])

# Sort statements chronologically
sorted_statements = sorted(
    discussion.statements,
    key=lambda s: (s.order or 0, s.id)
)

# Apply deltas for each statement in order
for stmt in sorted_statements:
    # Determine which PDPDeltas to use (AI or approved auditor correction)
    pdp_deltas_model = get_approved_or_ai_deltas(stmt)

    # Apply deltas using same logic as production extraction
    if pdp_deltas_model:
        cumulative_pdp_state = pdp.apply_deltas(
            cumulative_pdp_state,
            pdp_deltas_model
        )

    # Create snapshot for this statement
    cumulative_pdp = asdict(cumulative_pdp_state)

    # Pass to template
    statements_with_feedback.append({
        "statement": stmt,
        "pdp_deltas": stmt.pdp_deltas,
        "cumulative_pdp": cumulative_pdp,  # Snapshot up to this point
        ...
    })
```

**Key Points**:
- Cumulative is calculated **server-side during page render**
- Uses `pdp.apply_deltas()` (NOT `pdp.cumulative()`) for consistency with production
- Each statement gets a cumulative snapshot showing "state up to this point"
- Includes deletes (unlike `pdp.cumulative()` which is display-only)
- Uses approved auditor corrections if available, otherwise AI extraction

#### Refresh Mechanism

**Current Behavior**: Full page reload with URL parameter preservation

Cumulative updates happen via:

1. **Manual page reload** (browser refresh button)
2. **Feedback submission** → `reloadPreservingParams()` after 1 second
3. **Approval/unapproval** → `reloadPreservingParams()` immediately
4. **SSE new message event** → `reloadPreservingParams()` after 2 seconds

**Helper Function** ([discussion_audit.html:688-690](../btcopilot/training/templates/discussion_audit.html)):
```javascript
function reloadPreservingParams() {
    window.location.href = window.location.href;  // Preserves query params including ?selected_auditor=<id>
}
```

**Auto-Save Does NOT Reload**:
```javascript
// Auto-save function - doesn't reload page, minimal notifications
function autoSaveExtractionFeedback(messageId, editedData) {
    // Saves to backend but NO page reload
    // Used for inline edits during typing
}
```

**Manual Submit DOES Reload**:
```javascript
// Manual feedback function - shows notifications and reloads page
function submitExtractionFeedback(messageId, thumbsDown, editedData) {
    fetch('/training/feedback/', ...)
        .then(data => {
            if (data.success) {
                setTimeout(() => reloadPreservingParams(), 1000);
            }
        });
}
```

#### Component Communication

**Scope**: Columns 2 and 3 are **separate Alpine.js component instances**

**Data Flow**:
1. Both columns receive data from server-side template variables
2. Column 2: `{% set data = item.pdp_deltas %}`
3. Column 3: `{% set data = item.cumulative_pdp %}`
4. NO direct JavaScript communication between columns
5. NO shared Alpine.js store

**Synchronized Expand/Collapse**:
```javascript
function toggleSection(componentId) {
    // Finds both data and cumulative sections by component ID
    const dataCollapsed = document.getElementById('data-collapsed-' + componentId);
    const dataExpanded = document.getElementById('data-expanded-' + componentId);
    const cumulativeCollapsed = document.getElementById('cumulative-collapsed-' + componentId);
    const cumulativeExpanded = document.getElementById('cumulative-expanded-' + componentId);

    // Toggle both in sync via DOM manipulation
    if (isExpanded) {
        dataCollapsed.style.display = 'block';
        cumulativeCollapsed.style.display = 'block';
        dataExpanded.style.display = 'none';
        cumulativeExpanded.style.display = 'none';
    } else {
        // Expand both
    }
}
```

**No Event Dispatching**: Columns don't fire Alpine.js custom events to each other.

#### CRITICAL: Jinja2 Variable Scope Isolation

**Issue**: Jinja2 `{% set %}` variables persist across `<td>` boundaries within the same row. Without explicit resets, Column 3 (Cumulative) inherits variables from Column 2 (Changes).

**Manifestation**: Cumulative column would display auditor's edited extraction instead of full cumulative state when `feedback_data` leaked from Column 2.

**Fix** ([discussion_audit.html:517-523](../btcopilot/training/templates/discussion_audit.html)):
```jinja2
<!-- Column 3 must explicitly reset all Column 2 variables -->
{% set feedback_data = none %}
{% set all_ext_feedback = [] %}
{% set all_ext_feedback_dict = [] %}
{% set admin_ext_feedback = none %}
{% set approved = false %}
{% set approved_by = none %}
{% set approved_at = none %}
```

**Why this matters**: Without these resets, the component's initialization logic uses leaked `feedback_data.edited_extraction` instead of `item.cumulative_pdp`, causing cumulative to show only the current statement's deltas instead of the accumulated state.

**Rule**: When including the same component multiple times in a row, **always explicitly reset all variables** that shouldn't carry over.

#### Cumulative Data Source Logic

**Which extraction is included in cumulative?**

```python
# For each statement, determine source (discussions.py:710-786)
if stmt.approved:
    # Use AI extraction
    pdp_deltas_model = from_dict(PDPDeltas, stmt.pdp_deltas)
else:
    # Check for approved auditor feedback
    approved_feedback = Feedback.query.filter(
        Feedback.statement_id == stmt.id,
        Feedback.approved == True,
        Feedback.feedback_type == "extraction"
    ).first()

    if approved_feedback:
        # Use approved auditor correction
        pdp_deltas_model = from_dict(PDPDeltas, approved_feedback.edited_extraction)
    else:
        # Use AI extraction (not approved, but shown as cumulative context)
        pdp_deltas_model = from_dict(PDPDeltas, stmt.pdp_deltas)
```

**Important**: Cumulative includes **approved-only OR all extractions** depending on filter context. Review code for exact logic.

#### Performance Implementation

**Current approach** ([discussions.py:669-822](../btcopilot/training/routes/discussions.py)):

1. **SQLAlchemy Eager Loading** (lines 669-675):
```python
discussion = (
    Discussion.query
    .options(
        subqueryload(Discussion.statements).joinedload(Statement.speaker)
    )
    .get_or_404(discussion_id)
)
```
Eliminates N speaker lazy loads.

2. **Preload All Feedback** (lines 686-696):
```python
all_feedback = (
    Feedback.query
    .join(Statement)
    .filter(Statement.discussion_id == discussion_id)
    .all()
)
feedback_by_statement = defaultdict(lambda: {"conversation": [], "extraction": []})
for fb in all_feedback:
    feedback_by_statement[fb.statement_id][fb.feedback_type].append(fb)
```
Avoids N+1 queries by loading all feedback upfront.

3. **Incremental Cumulative Calculation** (lines 697-822):
```python
# Build dictionaries for O(1) upserts instead of O(N) deep copies
cumulative_people_by_id = {}
cumulative_events_by_id = {}

for stmt in sorted_statements:
    if pdp_deltas_model:
        # Upsert people/events by ID (same semantics as apply_deltas)
        for person in pdp_deltas_model.people:
            cumulative_people_by_id[person.id] = person
        for event in pdp_deltas_model.events:
            cumulative_events_by_id[event.id] = event
        # Process deletes
        for delete_id in pdp_deltas_model.delete:
            cumulative_people_by_id.pop(delete_id, None)
            cumulative_events_by_id.pop(delete_id, None)

    # Create snapshot
    cumulative_pdp = {
        "people": [asdict(p) for p in cumulative_people_by_id.values()],
        "events": [asdict(e) for e in cumulative_events_by_id.values()],
    }
```
Builds cumulative state incrementally using dictionaries (O(N) time complexity) instead of calling `pdp.apply_deltas()` N times (O(N²) with deep copy overhead). Maintains identical upsert/delete semantics.

#### GOTCHA: Cumulative Does NOT Auto-Update

**Current limitation**: After editing SARF codes in column 2:
- ✅ Auto-save persists changes to backend
- ✅ Column 2 updates immediately (Alpine.js reactivity)
- ❌ Column 3 does NOT update (server-rendered, no AJAX refresh)
- ✅ Manual page reload triggers cumulative recalculation with preserved auditor filter

**Workflow**: Domain experts should reload page (Cmd+R / Ctrl+R) after completing edits to a statement to see cumulative update before coding the next statement.

**Why not async refresh?**:
- Would require new API endpoint
- Complex Alpine.js component communication (columns are separate instances)
- Cascade problem: editing statement N affects cumulative for N+1, N+2, etc.
- Server-side calculation ensures consistency as single source of truth

**Implications**:
- Users must manually submit (not just auto-save) to see cumulative changes
- Or refresh entire page manually
- Cumulative may appear "stale" during editing sessions

---

### 3.5 Tab System (Admin Only)

**Condition** (lines 104-127):
```html
{% if current_user and current_user.has_role(btcopilot.ROLE_ADMIN) and all_ext_feedback_dict|length > 1 %}
<div class="tabs is-small is-boxed mb-0">
    <ul>
        <!-- AI Tab -->
        <li :class="{ 'is-active': selectedIndex === -1 }">
            <a @click.stop="selectFeedback(-1, null)">
                <span class="icon"><i class="fas fa-robot"></i></span>
                <span>AI</span>
            </a>
        </li>

        <!-- Auditor Tabs -->
        {% for feedback in all_ext_feedback_dict %}
        <li :class="{ 'is-active': selectedIndex === {{ loop.index0 }} }">
            <a @click.stop="selectFeedback({{ loop.index0 }}, allFeedback[{{ loop.index0 }}])">
                <span class="icon"><i class="fas fa-user"></i></span>
                <span>
                    {{ auditor_user_map.get(feedback.auditor_id, feedback.auditor_id) }}
                    {% if feedback.approved %} ✓{% endif %}
                </span>
            </a>
        </li>
        {% endfor %}
    </ul>
</div>
{% endif %}
```

**Display Logic**:
- Tabs only shown if: (1) user is admin AND (2) `all_ext_feedback_dict|length > 1` (multiple versions exist)
- Regular auditors always see their own editable version (no tabs)
- AI tab always available to admins
- Checkmark (✓) appears on approved tab label

**Tab Switching**:
```javascript
selectFeedback(index, feedback) {
    this.selectedIndex = index;
    this.selectedFeedback = feedback;

    if (index === -1) {
        // AI tab - show original extraction
        this.approved = this.originalApproved;
        this.approvedBy = this.originalApprovedBy;
        this.approvedAt = this.originalApprovedAt;
    } else {
        // Auditor tab - show feedback approval state
        this.approved = feedback.approved;
        this.approvedBy = feedback.approved_by;
        this.approvedAt = feedback.approved_at;
    }
}
```

---

### 3.6 Approval Button Logic

**Location** (lines 160-217)

**For AI Extraction** (selectedIndex === -1):
```html
<template x-if="selectedIndex === -1 || typeof selectedIndex === 'undefined'">
    <div>
        <!-- Already Approved State -->
        <template x-if="approved">
            <!-- Green checkmark that turns red X on hover -->
            <button class="tag is-success is-small approval-button"
                    @click.stop="unapproveStatement({{ message_id }})"
                    @mouseenter="$el.style.backgroundColor = '#f14668';
                                 $el.querySelector('i').className = 'fas fa-times'"
                    @mouseleave="$el.style.backgroundColor = '#48c78e';
                                 $el.querySelector('i').className = 'fas fa-check'">
                <i class="fas fa-check"></i>
            </button>
        </template>

        <!-- Not Approved State -->
        <template x-if="!approved">
            <button class="button is-success is-small"
                    @click.stop="approveStatement({{ message_id }})">
                <i class="fas fa-check"></i>
            </button>
        </template>
    </div>
</template>
```

**For Auditor Correction** (selectedIndex >= 0):
```html
<template x-if="selectedIndex >= 0 && selectedFeedback">
    <!-- Similar structure with approveFeedback/unapproveFeedback -->
</template>
```

**Interaction Flow**:
1. Not approved → shows grey button with check icon
2. Click → approve → button turns green tag with check
3. Hover over approved → turns red with X icon (unapprove preview)
4. Click while hovering → unapprove → back to grey button
5. Page reloads after approve/unapprove to reflect mutual exclusivity

---

## 4. API Endpoints

### 4.1 Feedback Submission

**Route**: `POST /training/feedback/`
**File**: [btcopilot/training/routes/feedback.py:207](../btcopilot/training/routes/feedback.py)
**Authorization**: `@login_required`, auditors and admins

**Request Body**:
```json
{
    "message_id": 123,
    "feedback_type": "extraction",
    "thumbs_down": false,
    "comment": "Optional comment",
    "edited_extraction": {
        "people": [...],
        "events": [...],
        "delete": [...]
    }
}
```

**Behavior** (lines 217-248):
```python
# Upsert logic - update existing or create new
existing = Feedback.query.filter_by(
    statement_id=data["message_id"],
    auditor_id=auditor_id,
    feedback_type=data["feedback_type"],
).first()

if existing:
    existing.thumbs_down = data.get("thumbs_down", False)
    existing.comment = data.get("comment")
    existing.edited_extraction = data.get("edited_extraction")
    existing.updated_at = func.now()
    db.session.commit()
    return jsonify({"success": True, "updated": True, "feedback_id": existing.id})
else:
    feedback = Feedback(
        statement_id=data["message_id"],
        auditor_id=auditor_id,
        feedback_type=data["feedback_type"],
        thumbs_down=data.get("thumbs_down", False),
        comment=data.get("comment"),
        edited_extraction=data.get("edited_extraction"),
    )
    db.session.add(feedback)
    db.session.commit()
    return jsonify({"success": True, "created": True, "feedback_id": feedback.id})
```

**Response**:
```json
{"success": true, "updated": true, "feedback_id": 456}
// OR
{"success": true, "created": true, "feedback_id": 456}
```

**Logging** (lines 239-245):
```python
event_count = len(data.get("edited_extraction", {}).get("events", []))
people_count = len(data.get("edited_extraction", {}).get("people", []))
_log.info(f"SARF feedback updated - event_count: {event_count}, people: {people_count}")
```

---

### 4.2 Approval Routes

**AI Extraction Approval**:
- **Route**: `POST /training/admin/approve-statement`
- **File**: [btcopilot/training/routes/admin.py:780](../btcopilot/training/routes/admin.py)
- **Body**: `{"statement_id": 123}`
- **Effect**: Sets `Statement.approved = True`, unapproves all feedback for that statement
- **Authorization**: `@minimum_role(btcopilot.ROLE_ADMIN)`

**Auditor Correction Approval**:
- **Route**: `POST /training/admin/quick-approve`
- **File**: [btcopilot/training/routes/admin.py:850](../btcopilot/training/routes/admin.py)
- **Body**: `{"feedback_id": 456}`
- **Effect**: Sets `Feedback.approved = True`, unapproves statement and all other feedback
- **Authorization**: `@minimum_role(btcopilot.ROLE_ADMIN)`

**AI Extraction Unapproval**:
- **Route**: `POST /training/admin/unapprove-statement`
- **Body**: `{"statement_id": 123}`
- **Effect**: Sets `Statement.approved = False`, clears approval metadata

**Auditor Correction Unapproval**:
- **Route**: `POST /training/admin/unapprove-feedback`
- **Body**: `{"feedback_id": 456}`
- **Effect**: Sets `Feedback.approved = False`, clears approval metadata

**Common Response**:
```json
{"success": true}
```

---

### 4.3 Export Route

**Function**: `btcopilot.training.export_tests.export_approved_test_cases()`
**Trigger**: Likely manual admin action or scheduled task (route not shown in exploration)

**Behavior**:
1. Query all `Statement` records where `approved == True` and `exported_at == None`
2. Query all `Feedback` records where `approved == True` and `exported_at == None`
3. For each approved statement:
   - Check if approved feedback exists for same statement
   - If yes: Skip statement export (feedback wins), mark statement as exported
   - If no: Export AI extraction as test case JSON
4. For each approved feedback:
   - Export auditor correction as test case JSON
5. Mark all exported items with `exported_at = datetime.utcnow()`

**Returns**: Count of exported test cases

---

### 4.4 Speaker Mapping

**Route**: `PUT /training/speakers/<speaker_id>`
**File**: [btcopilot/training/routes/speakers.py:23](../btcopilot/training/routes/speakers.py)
**Authorization**: `@login_required`, auditors and admins

**Purpose**: Map discussion speakers (detected from audio/transcript) to Person objects in diagram database

**Request Body**:
```json
{
    "person_id": -1,     // -1 = create new person, positive = existing person
    "name": "John Doe",  // Used if creating new person
    "type": "subject"    // "subject" (user/patient) or "expert" (AI assistant)
}
```

**Behavior**:
```python
if data.get("person_id") == -1 and data.get("name"):
    # Create new person in diagram
    diagram_data = discussion.diagram.get_diagram_data()
    new_person = Person(name=data["name"])
    diagram_data.add_person(new_person)  # Assigns new positive ID
    discussion.diagram.set_diagram_data(diagram_data)

    speaker.person_id = new_person.id
    speaker.type = data.get("type", "subject")
    db.session.commit()

    return jsonify({"success": True, "person_id": new_person.id})
else:
    # Just update speaker mapping
    speaker.person_id = data.get("person_id")
    speaker.type = data.get("type", "subject")
    db.session.commit()

    return jsonify({"success": True})
```

**Response**:
```json
{"success": true, "person_id": 5}  // If person was created
// OR
{"success": true}  // If just mapped to existing person
```

---

## 5. Critical Business Logic

### 5.1 Why Only One Approval Per Statement

**Rationale**: Ground truth must be unambiguous for model training and evaluation.

**Either/Or Logic**:
- **AI was correct** → Approve `Statement.pdp_deltas` as ground truth
- **AI was wrong** → Approve one auditor's `Feedback.edited_extraction` as ground truth
- **Never both** → Would create conflicting training signals

**Consequences of Multiple Approvals**:
- Test cases need single `expected_output`
- Model evaluation requires clear right/wrong signal
- Multiple approved versions would confuse model fine-tuning

**Enforcement**: Every approval function explicitly unapproves the alternatives (see section 1.3)

**UI Impact**: Page reloads after approval to show updated mutual exclusivity state

---

### 5.2 How Deletes Work in Ground Truth Coding

**In AI Extraction** (`Statement.pdp_deltas`):
```python
{
    "people": [],
    "events": [],
    "delete": [-101, -102]  // Negative IDs of items to remove from PDP
}
```

**Semantics**: "Remove these items that were extracted in previous statements"

**In Auditor Correction** (`Feedback.edited_extraction`):
- Complete replacement - no need for explicit `delete` array
- Simply omit items from `people`/`events` arrays
- UI provides "Remove" buttons that filter items out before submission

**In cumulative()** ([btcopilot/pdp.py:134](../btcopilot/pdp.py)):
```python
# Does NOT process deletes - only accumulates additions
for stmt in prior_statements:
    if stmt.pdp_deltas:
        cumulative_pdp.people.extend(stmt.pdp_deltas["people"])
        cumulative_pdp.events.extend(stmt.pdp_deltas["events"])
        # NOTE: Ignores "delete" array
```

**In apply_deltas()** ([btcopilot/pdp.py:202](../btcopilot/pdp.py)):
```python
# Processes deletes when applying to actual PDP
to_delete_ids = set(deltas.delete)

for idx in reversed(range(len(pdp.people))):
    if pdp.people[idx].id in to_delete_ids:
        del pdp.people[idx]

for idx in reversed(range(len(pdp.events))):
    if pdp.events[idx].id in to_delete_ids:
        del pdp.events[idx]
```

**GOTCHA**: `cumulative()` is for display only and doesn't apply deletes. See section 5.3.

---

### 5.3 PDPDeltas Merge Logic: cumulative() vs apply_deltas()

**CRITICAL DIFFERENCE**: These two functions have different semantics.

#### cumulative() - Display Context Only

**Purpose**: Show "what the AI had seen so far" when auditing a statement

**Algorithm**: Additive accumulation
```python
def cumulative(discussion, up_to_statement):
    cumulative_pdp = PDP()
    # NOTE: stmt.pdp_deltas is a JSON column, so it's always dicts (never dataclass instances)
    for stmt in prior_statements:
        if "people" in stmt.pdp_deltas:
            for person_data in stmt.pdp_deltas["people"]:
                cumulative_pdp.people.append(Person(**person_data))

        if "events" in stmt.pdp_deltas:
            for event_data in stmt.pdp_deltas["events"]:
                cumulative_pdp.events.append(Event(**event_data))

        if "pair_bonds" in stmt.pdp_deltas:
            for pair_bond_data in stmt.pdp_deltas["pair_bonds"]:
                cumulative_pdp.pair_bonds.append(PairBond(**pair_bond_data))
        # Ignores "delete" array
    return cumulative_pdp
```

**Characteristics**:
- Only adds, never removes
- May contain duplicates if IDs re-extracted
- May contain deleted items (doesn't process `delete` array)
- Not suitable for actual PDP state management
- Handles missing keys (`people`, `events`, `pair_bonds`) for backward compatibility
- **Data Contract**: `stmt.pdp_deltas` is always dicts (stored as JSON in database). If wrong type, function will fail fast with TypeError.

#### apply_deltas() - State Management

**Purpose**: Apply PDPDeltas to actual PDP state for diagram updates

**Algorithm**: Full merge with upsert and delete
```python
def apply_deltas(pdp, deltas):
    pdp = copy.deepcopy(pdp)

    # Build ID maps (people, events, pair_bonds share ID namespace)
    people_by_id = {item.id: item for item in pdp.people}
    events_by_id = {item.id: item for item in pdp.events}
    pair_bonds_by_id = {item.id: item for item in pdp.pair_bonds}

    # Separate adds and updates for people
    for item in deltas.people:
        if item.id in people_by_id:
            # Update existing (only changed fields)
            for field in item.model_fields_set:
                setattr(people_by_id[item.id], field, getattr(item, field))
        else:
            # Add new
            pdp.people.append(item)

    # Same logic for events and pair_bonds...

    # Process deletes (removes from all three lists)
    to_delete = set(deltas.delete)
    pdp.people = [p for p in pdp.people if p.id not in to_delete]
    pdp.events = [e for e in pdp.events if e.id not in to_delete]
    pdp.pair_bonds = [pb for pb in pdp.pair_bonds if pb.id not in to_delete]

    return pdp
```

**Characteristics**:
- Updates existing items (by ID match)
- Adds new items
- Removes deleted items (from all collections)
- Deduplicates by ID
- Suitable for actual state management
- Handles people, events, and pair_bonds separately (they share ID namespace)

**When to Use Which**:
- **cumulative()**: Displaying conversation context in UI
- **apply_deltas()**: Updating diagram PDP after AI extraction

---

### 5.4 Test Case Export Format

**File Naming Convention**:
- AI extraction: `stmt_{statement_id}.json`
- Auditor correction: `stmt_{statement_id}_corrected.json`

**Complete Structure**:
```json
{
    "test_id": "stmt_123",
    "source": "statement",
    "statement_id": 123,

    "inputs": {
        "conversation_history": [
            {"speaker": "Subject", "text": "I had a hard week at work"},
            {"speaker": "Expert", "text": "What made it difficult?"},
            {"speaker": "Subject", "text": "My boss criticized my project"}
        ],

        "database": {
            "people": [
                {"id": 1, "name": "User", "confidence": 1.0},
                {"id": 2, "name": "Assistant", "confidence": 1.0}
            ],
            "events": [],
            "pdp": {"people": [], "events": [], "pair_bonds": []},
            "lastItemId": 2
        },

        "current_pdp": {
            "people": [
                {"id": -1, "name": "Boss", "confidence": 0.9}
            ],
            "events": [
                {
                    "id": -2,
                    "kind": "shift",
                    "person": 1,
                    "description": "Hard week at work",
                    "anxiety": "up",
                    "confidence": 0.85
                }
            ]
        },

        "user_statement": "My boss criticized my project",

        "custom_prompts": {}
    },

    "expected_output": {
        "people": [],
        "events": [
            {
                "id": -3,
                "kind": "shift",
                "person": 1,
                "description": "Boss criticized project",
                "relationship": "conflict",
                "relationshipTargets": [-1],
                "anxiety": "up",
                "confidence": 0.8
            }
        ],
        "delete": []
    }
}
```

**For Auditor Corrections** (additional fields):
```json
{
    ...
    "source": "feedback",
    "feedback_id": 456,
    "auditor_id": "john.doe@example.com",

    "original_output": {
        "people": [],
        "events": [
            {
                "id": -3,
                "relationship": "distance",  // AI got this wrong
                ...
            }
        ],
        "delete": []
    },

    "feedback_comment": "Corrected relationship from distance to conflict based on confrontational language"
}
```

**Test Harness Integration**:
1. Load test case JSON from `./model_tests/data/`
2. Construct LLM prompt with `inputs`
3. Run model to generate output PDPDeltas
4. Compare output to `expected_output`
5. Calculate metrics:
   - Person extraction accuracy
   - Event extraction accuracy
   - SARF variable coding accuracy (per variable)
   - Relationship type accuracy
   - Overall F1 score

---

## 6. File Organization

### 6.1 Key Files in btcopilot/training/

**Models**:
- [models.py](../btcopilot/training/models.py) - Feedback model definition

**Routes** (all in `btcopilot/training/routes/`):
- [feedback.py](../btcopilot/training/routes/feedback.py) - Feedback submission, download
- [admin.py](../btcopilot/training/routes/admin.py) - Approval/unapproval, user management
- [discussions.py](../btcopilot/training/routes/discussions.py) - Discussion import, extraction triggering
- [speakers.py](../btcopilot/training/routes/speakers.py) - Speaker-to-person mapping
- [audit.py](../btcopilot/training/routes/audit.py) - Auditor dashboard

**Logic**:
- [export_tests.py](../btcopilot/training/export_tests.py) - Test case export functions
- [utils.py](../btcopilot/training/utils.py) - Breadcrumbs, auditor ID helpers

---

### 6.2 Templates

**Main Views** (all in `btcopilot/training/templates/`):
- [auditor_dashboard.html](../btcopilot/training/templates/auditor_dashboard.html) - Auditor's own discussions list
- [discussion_audit.html](../btcopilot/training/templates/discussion_audit.html) - Single discussion audit view with all statements
- [therapist_admin.html](../btcopilot/training/templates/therapist_admin.html) - Admin view of all users/discussions
- [feedback_index.html](../btcopilot/training/templates/feedback_index.html) - Admin feedback review page
- [therapist_base.html](../btcopilot/training/templates/therapist_base.html) - Base template with CSS for SARF variables

**Components** (all in `btcopilot/training/templates/components/`):
- [extracted_data_display.html](../btcopilot/training/templates/components/extracted_data_display.html) - **THE MAIN SARF EDITOR COMPONENT** (1000+ lines)
- [extracted_data_simple.html](../btcopilot/training/templates/components/extracted_data_simple.html) - Read-only display variant
- [extracted_data_corrected.html](../btcopilot/training/templates/components/extracted_data_corrected.html) - Another display variant
- [README.md](../btcopilot/training/templates/components/README.md) - Component documentation

**Macros**:
- [macros/discussion_box.html](../btcopilot/training/templates/macros/discussion_box.html) - Discussion card with metadata

---

### 6.3 Shared Schema with btcopilot/personal

**CRITICAL**: The following are SHARED between training and personal apps.

**From** [btcopilot/schema.py](../btcopilot/schema.py):
- `Person` dataclass
- `Event` dataclass
- `PDP`, `PDPDeltas` dataclasses
- `DiagramData` dataclass
- `VariableShift` enum (S, A, F variables)
- `RelationshipKind` enum (R variable)
- `EventKind` enum

**From** [btcopilot/personal/models/](../btcopilot/personal/models/):
- [discussion.py](../btcopilot/personal/models/discussion.py) - Discussion model
- [statement.py](../btcopilot/personal/models/statement.py) - Statement model (with pdp_deltas)
- [speaker.py](../btcopilot/personal/models/speaker.py) - Speaker model

**Why Shared**: Training app codes ground truth for the same extraction model used by personal app.

**GOTCHA**: Changes to schema affect BOTH apps. Always consider personal app impact when modifying SARF schema.

**Cross-App Workflow**:
1. Personal app: User has therapy conversation
2. Personal app: AI extracts SARF data → `Statement.pdp_deltas`
3. Training app: Domain expert reviews extraction
4. Training app: Expert makes corrections → `Feedback.edited_extraction`
5. Training app: Admin approves ground truth
6. Training app: Export to test case JSON
7. Model training: Use test cases to fine-tune extraction model
8. Personal app: Improved AI serves users

---

### 6.4 Test Case Export Directory

**Directory**: `./model_tests/data/uncategorized/`

**Created By**: [export_tests.py:31](../btcopilot/training/export_tests.py)
```python
export_dir = Path("./model_tests/data/uncategorized")
export_dir.mkdir(parents=True, exist_ok=True)
```

**Organization**:
- Initially exported to `uncategorized/`
- Presumably manually moved to categorized folders later (e.g., `conflict/`, `anxiety/`)
- Each test case is standalone JSON file

**Relative To**: Repository root (where `manage.py` lives)

**Typical Structure**:
```
./model_tests/
├── data/
│   ├── uncategorized/
│   │   ├── stmt_123.json
│   │   ├── stmt_124_corrected.json
│   │   └── ...
│   ├── anxiety/
│   │   └── ...
│   ├── relationship/
│   │   └── ...
│   └── functioning/
│       └── ...
└── test_runner.py (presumably)
```

---

## 7. Design Patterns & Gotchas

### Pattern 1: Upsert on Submit

**Implementation**: [feedback.py:217](../btcopilot/training/routes/feedback.py)

**Behavior**:
- UI submits complete extraction on every edit
- Backend checks for existing feedback by `(statement_id, auditor_id, feedback_type)`
- Updates if exists, creates if new

**Benefits**:
- Avoids duplicate feedback records
- Auditor can iteratively refine corrections
- Simple UI logic (always POST same endpoint)

**Code**:
```python
existing = Feedback.query.filter_by(
    statement_id=data["message_id"],
    auditor_id=auditor_id,
    feedback_type=data["feedback_type"],
).first()

if existing:
    existing.edited_extraction = data.get("edited_extraction")
    existing.updated_at = func.now()
else:
    feedback = Feedback(...)
    db.session.add(feedback)
```

---

### Pattern 2: Mutual Exclusivity Enforcement

**Implementation**: [admin.py:780, 850](../btcopilot/training/routes/admin.py)

**Behavior**: Every approval function explicitly unapproves alternatives

**Code Pattern**:
```python
def approve_X():
    # Step 1: Unapprove all conflicting approvals
    for conflicting_item in get_conflicting_approvals():
        conflicting_item.approved = False
        conflicting_item.approved_by = None
        conflicting_item.approved_at = None

    # Step 2: Approve target
    target.approved = True
    target.approved_by = current_user.username
    target.approved_at = datetime.utcnow()
```

**Benefits**:
- Enforces business rule at data layer
- Prevents inconsistent ground truth
- Self-healing if UI state gets out of sync

**UI Impact**: Page reloads after approval to show updated state

---

### Pattern 3: Alpine.js Component Composition

**Base**: `componentExtractedData()` (not shown, presumed simpler version)

**Extended**: `componentExtractedDataWithReview()` in [discussion_audit.html:1533](../btcopilot/training/templates/discussion_audit.html)

**Benefits**:
- Reuse editing logic across contexts
- Extend with approval workflow for admin views
- Keep component files focused

---

### Gotcha 1: Negative IDs Convention

**Convention**:
- Positive IDs (1, 2, 3, ...): Committed diagram items
- Negative IDs (-1, -2, -3, ...): PDP pending items

**Validation** ([pdp.py:58](../btcopilot/pdp.py)):
```python
for person in pdp.people:
    if person.id >= 0:
        errors.append(f"Person {person.id} has non-negative ID in PDP (must be negative)")
```

**Why**: Allows mixing PDP references with committed diagram references in same event

**Example**:
```python
Event(
    person=1,  # Committed person (User)
    relationshipTargets=[-5],  # PDP person (not yet confirmed)
)
```

---

### Gotcha 2: cumulative() vs apply_deltas()

**See Section 5.3** for full details.

**Summary**:
- **cumulative()**: Additive-only, ignores deletes, for display context
- **apply_deltas()**: Full merge with upsert and deletes, for state management

**Don't Confuse**:
- `cumulative()` output may have duplicates and deleted items
- Not suitable for actual PDP state (diagram updates)
- Only use for "Cumulative Notes" UI display

---

### Gotcha 3: Person Reference Tracking

**Problem**: Alpine.js doesn't reactively update person name lookups when person data changes

**Solution**: `personDataVersion` counter ([extracted_data_display.html:47](../btcopilot/training/templates/components/extracted_data_display.html))

```javascript
{
    personDataVersion: 0,  // Incremented when persons change

    getPersonName(personId) {
        this.personDataVersion;  // Access to create reactive dependency
        const person = this.extractedData.people.find(p => p.id === personId);
        return person?.name || `Person ${personId}`;
    },

    savePersonName(index, newName) {
        this.extractedData.people[index].name = newName;
        this.personDataVersion++;  // Trigger re-render of all person lookups
        this.submitFeedback();
    }
}
```

**Why Needed**: Alpine.js doesn't detect nested object changes (`people[0].name`)

---

### Gotcha 4: Export Mutual Exclusivity

**Problem**: If both statement and feedback approved for same statement, which gets exported?

**Solution**: Feedback wins ([export_tests.py:42](../btcopilot/training/export_tests.py))

```python
for statement in approved_statements:
    # Check if approved feedback exists
    approved_feedback = Feedback.query.filter(
        Feedback.statement_id == statement.id,
        Feedback.approved == True
    ).first()

    if approved_feedback:
        # Mark statement as exported but DON'T create file
        statement.exported_at = datetime.utcnow()
        continue

    # Only export AI version if no approved feedback exists
    create_statement_test_case(statement)
```

**Consequence**: Statement marked `exported_at` but no file created

**Rationale**: Corrected version is more valuable ground truth than AI version

---

## 8. Testing Considerations

When modifying this system, test these scenarios:

### Test 1: Approval Mutual Exclusivity
1. Approve statement (AI extraction)
2. Verify `statement.approved == True`
3. Approve feedback for same statement
4. Verify `statement.approved == False` and `feedback.approved == True`
5. Approve statement again
6. Verify `feedback.approved == False` and `statement.approved == True`

### Test 2: Export Idempotency
1. Approve statement
2. Run export → verify file created
3. Run export again → verify no duplicate file, no errors

### Test 3: Cumulative Calculation
1. Create discussion with statements in order: A, B, C
2. Insert statement D with `id < B.id` but `order > B.order`
3. Calculate `cumulative(discussion, C)`
4. Verify includes A, B but NOT D (due to ID filter)

### Test 4: Negative ID Validation
1. Try creating PDP item with positive ID
2. Verify validation error raised
3. Try creating committed diagram item with negative ID
4. Verify error or auto-correction

### Test 5: Feedback Upsert
1. Submit feedback as auditor A for statement 123
2. Verify `Feedback` record created
3. Submit feedback again as auditor A for statement 123
4. Verify only ONE `Feedback` record exists (updated, not duplicated)

### Test 6: Alpine.js Tab Switching
1. Load discussion audit page with multiple auditor feedback
2. Click AI tab → verify shows original extraction
3. Click auditor tab → verify shows corrected extraction
4. Verify approval button state changes correctly

### Test 7: Person Reference Integrity
1. Create event referencing person ID -5 in relationshipTargets
2. Don't include person -5 in extraction
3. Verify validation error on submission

---

## 9. Migration Path for Schema Changes

If modifying SARF variables or Event structure, follow these steps:

### Step 1: Update btcopilot/schema.py
- Modify dataclass definitions
- Add/remove/rename fields
- Update enums if needed

### Step 2: Create Alembic Migration (if needed)
```bash
uv run python -m flask db migrate -m "Add new SARF variable"
uv run python -m flask db upgrade
```

**Note**: JSON columns don't have strict schema, but may need data migration script for existing records.

### Step 3: Update UI Component
- Edit [extracted_data_display.html](../btcopilot/training/templates/components/extracted_data_display.html)
- Add/remove form fields
- Update display logic
- Update submit payload

### Step 4: Update Export Format
- Edit [export_tests.py](../btcopilot/training/export_tests.py)
- Ensure new fields included in test case JSON
- Update test harness if needed

### Step 5: Update Validation
- Edit [btcopilot/pdp.py](../btcopilot/pdp.py):validate_pdp_deltas()
- Add validation rules for new fields
- Update error messages

### Step 6: Test in Personal App
- Verify AI extraction still works with schema changes
- Test `pdp.update()` generates correct deltas
- Check personal app UI displays new fields

### Step 7: Consider Backward Compatibility
- Existing `Feedback.edited_extraction` JSON may not have new fields
- Add default values when deserializing old records
- Consider data migration if critical

**Example Migration**:
```python
# In schema.py
@dataclass
class Event:
    ...
    new_field: str | None = None  # Add with default None for backward compat

# In routes when loading old feedback
def load_feedback_extraction(feedback):
    data = feedback.edited_extraction
    for event in data.get("events", []):
        if "new_field" not in event:
            event["new_field"] = None  # Backfill default
    return from_dict(PDPDeltas, data)
```

---

## 10. Related Documentation

- [DATA_MODEL_FLOW.md](./DATA_MODEL_FLOW.md) - Overall diagram data flow (PDP, pickle, IDs)
- [btcopilot/training/templates/components/README.md](../btcopilot/training/templates/components/README.md) - UI component documentation
- [btcopilot/CLAUDE.md](../CLAUDE.md) - General project guidance

---

## Appendix: Quick Reference Tables

### A. Model Comparison

| Model | Column | Purpose | Format | Approval |
|-------|--------|---------|--------|----------|
| Statement | pdp_deltas | AI extraction | JSON (PDPDeltas) | Statement.approved |
| Feedback | edited_extraction | Auditor correction | JSON (PDPDeltas) | Feedback.approved |

### B. SARF Variable Types

| Variable | Enum | Values | Purpose |
|----------|------|--------|---------|
| Symptom | VariableShift | up, down, same | Physical/psychological symptom change |
| Anxiety | VariableShift | up, down, same | Anxiety level change |
| Functioning | VariableShift | up, down, same | Daily functioning change |
| Relationship | RelationshipKind | 12 types | Relationship pattern/mechanism |

### C. API Endpoints Quick Reference

| Endpoint | Method | Auth | Purpose |
|----------|--------|------|---------|
| /training/feedback/ | POST | Auditor | Submit/update feedback |
| /training/admin/approve-statement | POST | Admin | Approve AI extraction |
| /training/admin/quick-approve | POST | Admin | Approve auditor correction |
| /training/admin/unapprove-statement | POST | Admin | Unapprove AI extraction |
| /training/admin/unapprove-feedback | POST | Admin | Unapprove auditor correction |
| /training/speakers/<id> | PUT | Auditor | Map speaker to person |

### D. File Locations Quick Reference

| Component | File |
|-----------|------|
| SARF editor UI | btcopilot/training/templates/components/extracted_data_display.html |
| Feedback model | btcopilot/training/models.py |
| Approval logic | btcopilot/training/routes/admin.py |
| Export logic | btcopilot/training/export_tests.py |
| Schema definitions | btcopilot/schema.py |
| PDPDeltas processing | btcopilot/pdp.py |

---

**End of Technical Reference**
