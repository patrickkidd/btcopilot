{% extends "base.html" %}

{% block head %}
<style>
.user-card {
    transition: background-color 0.2s ease;
}
.user-card.drag-over, .box.drag-over {
    background-color: rgba(0, 209, 178, 0.15) !important;
    border: 2px dashed var(--color-success-emphasis) !important;
}
.user-card:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}
.license-card {
    border: 1px solid var(--color-border-default);
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 1rem;
}
.license-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}
.activation-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.25rem;
}
.box.diagram-card {
    border: 1px solid var(--color-border-default);
    border-radius: 6px;
}
</style>
{% endblock %}

{% block content %}
<div>
    <h1 class="title">SARF Coding</h1>
    <p class="subtitle">Manage your diagrams, discussions, and SARF codes</p>

    <!-- F1 Ground Truth Metrics Section -->
    {% include "partials/f1_metrics_card.html" with context %}

    <!-- F1 Timeseries Graph -->
    {% include "partials/f1_timeseries.html" with context %}

    <!-- Two-column diagram layout -->
    <div class="columns">
        <div class="column is-6">
            {% include "partials/user_diagrams_owned.html" with context %}
        </div>
        <div class="column is-6">
            {% include "partials/user_diagrams_shared.html" with context %}
        </div>
    </div>

</div>

<script>
// Drag and drop functionality for audio/JSON files
function setupDragAndDrop() {
    const boxes = document.querySelectorAll('.box');
    
    boxes.forEach(box => {
        box.addEventListener('dragover', handleDragOver);
        box.addEventListener('dragleave', handleDragLeave);
        box.addEventListener('drop', handleDrop);
    });
}

function handleDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = 'copy';
    event.currentTarget.classList.add('drag-over');
}

function handleDragLeave(event) {
    event.stopPropagation();
    event.currentTarget.classList.remove('drag-over');
}

function handleDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.remove('drag-over');
    
    const files = event.dataTransfer.files;
    if (files.length > 0) {
        // Handle file upload logic here
        console.log('Files dropped:', files);
        // This would integrate with existing audio/JSON upload functionality
    }
}



async function handleAudioFileSelect(event, userId, diagramId) {
    const file = event.target.files[0];
    if (!file) return;
    
    console.log('Processing audio file:', file.name, 'for diagram:', diagramId);
    
    // Validate it's an audio file
    if (!file.type.startsWith('audio/')) {
        alert('Please select an audio file. Supported formats: MP3, WAV, M4A, MP4, FLAC, OGG, WEBM, AAC');
        return;
    }
    
    const confirmMessage = `Upload "${file.name}" to this diagram for transcription and analysis?`;
    if (!confirm(confirmMessage)) {
        return;
    }
    
    // Find the drop zone container for progress display
    const dropZone = event.target.closest('.box');
    const originalContent = dropZone.innerHTML;
    
    try {
        // Show progress
        dropZone.innerHTML = `
            <div class="notification is-info">
                <p><strong>Processing "${file.name}"...</strong></p>
                <progress class="progress is-small is-primary" value="20" max="100">20%</progress>
                <p class="is-size-7" id="upload-status">Getting upload token...</p>
            </div>
        `;
        
        // Get API key for AssemblyAI
        const keyResponse = await fetch('/training/discussions/upload_token');
        const keyData = await keyResponse.json();
        
        if (!keyData.success) {
            throw new Error(keyData.error || 'Failed to get upload token');
        }
        
        // Update progress
        const progressBar = dropZone.querySelector('.progress');
        const statusEl = dropZone.querySelector('#upload-status');
        if (progressBar) progressBar.value = 30;
        if (statusEl) statusEl.textContent = 'Uploading to transcription service...';
        
        // Upload to AssemblyAI
        const uploadResponse = await fetch('https://api.assemblyai.com/v2/upload', {
            method: 'POST',
            headers: {
                'authorization': `${keyData.api_key}`,
            },
            body: file
        });
        
        if (!uploadResponse.ok) {
            throw new Error(`Upload failed: ${await uploadResponse.text()}`);
        }
        
        const uploadData = await uploadResponse.json();
        
        // Update progress
        if (progressBar) progressBar.value = 60;
        if (statusEl) statusEl.textContent = 'Requesting transcription...';
        
        // Request transcription
        const transcriptResponse = await fetch('https://api.assemblyai.com/v2/transcript', {
            method: 'POST',
            headers: {
                'authorization': `${keyData.api_key}`,
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                audio_url: uploadData.upload_url,
                speaker_labels: true
            })
        });
        
        if (!transcriptResponse.ok) {
            throw new Error(`Transcription request failed: ${await transcriptResponse.text()}`);
        }
        
        const transcriptRequest = await transcriptResponse.json();
        
        // Update progress
        if (progressBar) progressBar.value = 80;
        if (statusEl) statusEl.textContent = 'Creating discussion...';
        
        // Poll for completion (simplified version)
        let transcriptData;
        let attempts = 0;
        const maxAttempts = 60; // 5 minutes max
        
        while (attempts < maxAttempts) {
            const pollResponse = await fetch(`https://api.assemblyai.com/v2/transcript/${transcriptRequest.id}`, {
                headers: { 'authorization': `${keyData.api_key}` }
            });
            
            transcriptData = await pollResponse.json();
            
            if (transcriptData.status === 'completed') {
                break;
            } else if (transcriptData.status === 'error') {
                throw new Error('Transcription failed: ' + transcriptData.error);
            }
            
            await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
            attempts++;
        }
        
        if (attempts >= maxAttempts) {
            throw new Error('Transcription timeout');
        }
        
        // Create discussion on server
        const createResponse = await fetch(`/training/discussions/transcript?title=${encodeURIComponent(file.name)}&diagram_id=${diagramId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(transcriptData)
        });
        
        const createData = await createResponse.json();
        if (!createData.success) {
            throw new Error(createData.error || 'Failed to create discussion');
        }
        
        // Success!
        if (progressBar) progressBar.value = 100;
        if (statusEl) statusEl.textContent = 'Complete! Processing statements...';
        
        setTimeout(() => {
            location.reload();
        }, 2000);
        
    } catch (error) {
        console.error('Upload error:', error);
        dropZone.innerHTML = `
            <div class="notification is-danger">
                <button class="delete" onclick="this.parentElement.outerHTML = '${originalContent.replace(/'/g, '\\\'')}'"></button>
                <p><strong>Upload failed:</strong> ${error.message}</p>
            </div>
        `;
    }
}

function handleJsonFileSelect(event, userId, diagramId) {
    const file = event.target.files[0];
    if (!file) return;
    
    // Create a fake drop event to reuse existing handleDiagramJsonDrop functionality
    const fakeEvent = {
        preventDefault: () => {},
        stopPropagation: () => {},
        currentTarget: {
            classList: {
                remove: () => {}
            },
            innerHTML: 'Processing...'
        },
        dataTransfer: {
            files: [file]
        }
    };
    
    // Use the existing handleDiagramJsonDrop function if available, or implement inline
    if (typeof handleDiagramJsonDrop === 'function') {
        handleDiagramJsonDrop(fakeEvent, diagramId);
    } else {
        // Inline implementation based on audit_index.html
        handleJsonDropInline(fakeEvent, diagramId);
    }
}

async function handleJsonDropInline(event, diagramId) {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget?.classList?.remove('drag-over');

    const files = event.dataTransfer.files;
    if (files.length === 0) return;
    
    const file = files[0];
    
    // Validate it's a JSON file
    if (!file.name.endsWith('.json') && file.type !== 'application/json') {
        alert('Please drop a JSON file (exported discussion)');
        return;
    }
    
    const confirmMessage = `Import "${file.name}" as a new discussion for this diagram?`;
    if (!confirm(confirmMessage)) {
        return;
    }
    
    try {
        // Read the file content
        const content = await file.text();
        const jsonData = JSON.parse(content);
        
        // Validate it looks like a discussion export
        if (!jsonData.id || !jsonData.statements) {
            alert('Invalid discussion export format');
            return;
        }
        
        // Import the discussion
        const response = await fetch('/training/discussions/import', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                discussion: jsonData,
                diagram_id: diagramId
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            alert(`Discussion imported successfully! ID: ${result.discussion_id}`);
            location.reload();
        } else {
            alert('Import failed: ' + (result.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error importing JSON:', error);
        alert('Failed to import discussion: ' + error.message);
    }
}

function deleteDiscussion(discussionId, username, statementCount) {
    if (statementCount > 0) {
        const message = `⚠️ WARNING: This discussion contains valuable data!

Discussion #${discussionId} has ${statementCount} statement${statementCount !== 1 ? 's' : ''}.

Deleting will permanently remove:
- All ${statementCount} statements
- All user feedback and corrections
- All extracted PDP deltas and training data

⚠️ This valuable training data cannot be recovered once deleted.

Are you SURE you want to delete this discussion?`;

        if (!confirm(message)) {
            return;
        }

        // Double confirmation for discussions with statements
        const doubleCheck = prompt(`To confirm deletion, type the number of statements (${statementCount}):`);
        if (doubleCheck !== statementCount.toString()) {
            alert('Deletion cancelled - confirmation did not match.');
            return;
        }
    } else {
        const message = `Delete Discussion #${discussionId}?

This discussion has no statements.

Are you sure you want to delete it?`;

        if (!confirm(message)) {
            return;
        }
    }

    fetch(`/training/discussions/${discussionId}`, {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            alert('Error deleting discussion: ' + data.error);
        }
    })
    .catch(error => {
        alert('Error deleting discussion: ' + error);
    });
}

// Initialize drag and drop when page loads
document.addEventListener('DOMContentLoaded', function() {
    setupDragAndDrop();
    setupDiagramDragAndDrop();
});

function setupDiagramDragAndDrop() {
    // Add drag and drop to diagram audio/json zones
    const audioZones = document.querySelectorAll('[id^="audio-drop-zone-diagram-"]');
    const jsonZones = document.querySelectorAll('[id^="json-drop-zone-diagram-"]');
    
    audioZones.forEach(zone => {
        const diagramId = zone.id.replace('audio-drop-zone-diagram-', '');
        zone.addEventListener('dragover', handleAudioDragOver);
        zone.addEventListener('dragleave', handleAudioDragLeave);
        zone.addEventListener('drop', (e) => handleAudioDrop(e, diagramId));
    });
    
    jsonZones.forEach(zone => {
        const diagramId = zone.id.replace('json-drop-zone-diagram-', '');
        zone.addEventListener('dragover', handleJsonDragOver);
        zone.addEventListener('dragleave', handleJsonDragLeave);
        zone.addEventListener('drop', (e) => handleJsonDropInline(e, diagramId));
    });
}

function handleJsonDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';
    event.currentTarget.classList.add('drag-over');
}

function handleJsonDragLeave(event) {
    event.currentTarget.classList.remove('drag-over');
}

function handleAudioDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';
    event.currentTarget.classList.add('drag-over');
}

function handleAudioDragLeave(event) {
    event.currentTarget.classList.remove('drag-over');
}

async function handleAudioDrop(event, diagramId) {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.remove('drag-over');
    
    const files = event.dataTransfer.files;
    if (files.length === 0) return;
    
    const file = files[0];
    
    // Create a fake file input event and call the existing handler
    const fakeEvent = {
        target: {
            files: [file],
            closest: () => event.currentTarget
        }
    };
    
    // Call the same handler as click selection
    await handleAudioFileSelect(fakeEvent, null, diagramId);
}

// Access Rights Management Functions
let cachedUsers = null;

async function loadUsers() {
    if (cachedUsers) return cachedUsers;

    try {
        // Server now filters to auditor+admin roles by default for performance
        const response = await fetch('/training/admin/users');
        const data = await response.json();
        cachedUsers = data.users || [];
        return cachedUsers;
    } catch (error) {
        console.error('Error loading users:', error);
        return [];
    }
}

async function toggleAccessRights(diagramId) {
    const panel = document.getElementById(`access-rights-${diagramId}`);
    const isVisible = panel.style.display !== 'none';

    if (isVisible) {
        panel.style.display = 'none';
    } else {
        panel.style.display = 'block';

        const users = await loadUsers();
        const userSelect = document.getElementById(`user-select-${diagramId}`);

        userSelect.innerHTML = '<option value="">Select user...</option>';
        users.forEach(user => {
            const option = document.createElement('option');
            option.value = user.id;
            option.textContent = `${user.username}${user.full_name ? ' - ' + user.full_name : ''}`;
            userSelect.appendChild(option);
        });

        await refreshAccessRights(diagramId);
    }
}

async function refreshAccessRights(diagramId) {
    const container = document.getElementById(`current-access-rights-${diagramId}`);

    try {
        const response = await fetch(`/training/diagrams/${diagramId}/access-rights`);
        const data = await response.json();

        if (!data.success) {
            container.innerHTML = '<p class="has-text-danger is-size-7">Error loading access rights</p>';
            return;
        }

        if (data.access_rights.length === 0) {
            container.innerHTML = '<p class="has-text-grey-light is-size-7">No users have access to this diagram</p>';
            return;
        }

        let html = '<table class="table is-fullwidth is-size-7 is-narrow">';
        html += '<thead><tr><th>User</th><th>Access</th><th>Actions</th></tr></thead><tbody>';

        data.access_rights.forEach(ar => {
            const accessLabel = ar.right === 'ro' ? 'Read-Only' : 'Read-Write';
            const accessClass = ar.right === 'ro' ? 'is-info' : 'is-success';
            const fullName = ar.user.first_name && ar.user.last_name
                ? `${ar.user.first_name} ${ar.user.last_name}`
                : '';

            html += `<tr>
                <td>${ar.user.username}${fullName ? ' - ' + fullName : ''}</td>
                <td><span class="tag ${accessClass} is-light">${accessLabel}</span></td>
                <td>
                    <div class="buttons are-small">
                        ${ar.right === 'ro' ?
                            `<button class="button is-small is-success" onclick="updateAccessRight(${diagramId}, ${ar.user_id}, 'rw')" title="Upgrade to Read-Write">
                                <span class="icon is-small"><i class="fas fa-arrow-up"></i></span>
                            </button>` :
                            `<button class="button is-small is-info" onclick="updateAccessRight(${diagramId}, ${ar.user_id}, 'ro')" title="Downgrade to Read-Only">
                                <span class="icon is-small"><i class="fas fa-arrow-down"></i></span>
                            </button>`
                        }
                        <button class="button is-small is-danger" onclick="revokeAccessRight(${diagramId}, ${ar.id})">
                            <span class="icon is-small"><i class="fas fa-times"></i></span>
                        </button>
                    </div>
                </td>
            </tr>`;
        });

        html += '</tbody></table>';
        container.innerHTML = html;

    } catch (error) {
        console.error('Error loading access rights:', error);
        container.innerHTML = '<p class="has-text-danger is-size-7">Error loading access rights</p>';
    }
}

async function grantAccess(diagramId) {
    const userSelect = document.getElementById(`user-select-${diagramId}`);
    const rightSelect = document.getElementById(`right-select-${diagramId}`);

    const userId = parseInt(userSelect.value);
    const right = rightSelect.value;

    if (!userId) {
        alert('Please select a user');
        return;
    }

    try {
        const response = await fetch(`/training/diagrams/${diagramId}/access-rights`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_id: userId, right })
        });

        const data = await response.json();

        if (data.success) {
            userSelect.value = '';
            await refreshAccessRights(diagramId);
        } else {
            alert('Error: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error granting access:', error);
        alert('Error granting access');
    }
}

async function updateAccessRight(diagramId, userId, newRight) {
    try {
        const response = await fetch(`/training/diagrams/${diagramId}/access-rights`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_id: userId, right: newRight })
        });

        const data = await response.json();

        if (data.success) {
            await refreshAccessRights(diagramId);
        } else {
            alert('Error: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error updating access:', error);
        alert('Error updating access');
    }
}

async function revokeAccessRight(diagramId, accessRightId) {
    if (!confirm('Revoke access for this user?')) {
        return;
    }

    try {
        const response = await fetch(`/training/diagrams/${diagramId}/access-rights/${accessRightId}`, {
            method: 'DELETE'
        });

        const data = await response.json();

        if (data.success) {
            await refreshAccessRights(diagramId);
        } else {
            alert('Error: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error revoking access:', error);
        alert('Error revoking access');
    }
}
</script>

<script src="{{ url_for('training.audit.static', filename='js/user-detail-component.js') }}"></script>
{% endblock %}