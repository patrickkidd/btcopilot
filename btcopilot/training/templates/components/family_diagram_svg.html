{#
Family Diagram SVG Component

Renders an HTML5/SVG family diagram based on the visual spec in
btcopilot/doc/FAMILY_DIAGRAM_VISUAL_SPEC.md

Parameters:
- data: Dict with 'people', 'pair_bonds', 'parent_child' lists
- layout: Dict with pre-computed 'people' and 'pairBonds' positions (from diagramlayout.compute)
#}

{% set PERSON_SIZE = 50 %}
{% set PERSON_SPACING = 120 %}
{% set GENERATION_GAP = 110 %}
{% set PAIR_BOND_DROP = (PERSON_SIZE / 2.2)|int %}
{% set NAME_OFFSET = (PERSON_SIZE * 0.2)|int %}

<style>
/* Inline styles for embed mode - uses CSS variables with fallbacks */
.family-diagram-svg .fd-person-shape {
    fill: none;
    stroke: var(--color-fg-default, #1a1a1a);
    stroke-width: 2;
}
.family-diagram-svg .fd-person-shape.primary {
    stroke-width: 3;
}
.family-diagram-svg .fd-person-deceased line {
    stroke: var(--color-fg-default, #1a1a1a);
    stroke-width: 2;
}
.family-diagram-svg .fd-person-primary-outer {
    fill: none;
    stroke: var(--color-fg-default, #1a1a1a);
    stroke-width: 2;
}
.family-diagram-svg .fd-person-age {
    fill: var(--color-fg-default, #1a1a1a);
    font-family: system-ui, -apple-system, sans-serif;
    font-size: 14px;
    text-anchor: middle;
    dominant-baseline: central;
}
.family-diagram-svg .fd-no-data {
    fill: var(--color-fg-muted, #666);
    font-size: 14px;
}
.family-diagram-svg .fd-person-name {
    fill: var(--color-fg-default, #1a1a1a);
    font-family: system-ui, -apple-system, sans-serif;
    font-size: 12px;
}
.family-diagram-svg .fd-pair-bond {
    fill: none;
    stroke: var(--color-fg-default, #1a1a1a);
    stroke-width: 2;
}
.family-diagram-svg .fd-pair-bond.bonded {
    stroke-dasharray: 8, 4;
}
.family-diagram-svg .fd-separation-slash {
    stroke: var(--color-fg-default, #1a1a1a);
    stroke-width: 2;
}
.family-diagram-svg .fd-child-line {
    fill: none;
    stroke: var(--color-fg-default, #1a1a1a);
    stroke-width: 2;
}
.family-diagram-svg .fd-child-line.adopted {
    stroke-dasharray: 8, 4;
}
.family-diagram-svg .fd-jig-line {
    fill: none;
    stroke: var(--color-fg-default, #1a1a1a);
    stroke-width: 2;
}
</style>

<svg class="family-diagram-svg"
     id="family-diagram-{{ statement_id }}"
     xmlns="http://www.w3.org/2000/svg"
     width="100%"
     height="400"
     viewBox="0 0 800 400"
     preserveAspectRatio="xMidYMid meet">

    <defs>
    </defs>

    <!-- Diagram content rendered by JavaScript -->
    <g class="fd-diagram-content" id="fd-content-{{ statement_id }}">
        <text x="400" y="200" text-anchor="middle" class="fd-person-name" style="font-size: 14px;">
            Loading diagram...
        </text>
    </g>
</svg>

<script>
(function() {
    const diagramData = {{ data | tojson }};
    const layout = {{ layout | tojson }};
    const statementId = {{ statement_id }};

    const PERSON_SIZE = 50;
    const PAIR_BOND_DROP = Math.floor(PERSON_SIZE / 2.2);
    const NAME_OFFSET = Math.floor(PERSON_SIZE * 0.2);

    function buildDiagram() {
        const svg = document.getElementById(`family-diagram-${statementId}`);
        const content = document.getElementById(`fd-content-${statementId}`);

        if (!svg || !content) return;
        content.innerHTML = '';

        if (!diagramData.people || diagramData.people.length === 0) {
            content.innerHTML = `
                <text x="400" y="200" text-anchor="middle" class="fd-no-data">
                    No family data to display
                </text>
            `;
            return;
        }

        updateViewBox(svg, layout);

        for (const pb of diagramData.pair_bonds) {
            const personA = layout.people[pb.person_a];
            const personB = layout.people[pb.person_b];
            if (personA && personB) {
                renderPairBond(content, pb, personA, personB, layout);
            }
        }

        for (const pc of diagramData.parent_child) {
            const child = layout.people[pc.child_id];
            const pairBond = layout.pairBonds[pc.pair_bond_id];
            if (child && pairBond) {
                renderChildConnection(content, child, pairBond);
            }
        }

        for (const person of diagramData.people) {
            const pos = layout.people[person.id];
            if (pos) {
                renderPerson(content, person, pos);
            }
        }
    }

    function updateViewBox(svg, layout) {
        const positions = Object.values(layout.people);
        if (positions.length === 0) return;

        const padding = 50;
        let contentMinX = Math.min(...positions.map(p => p.x)) - PERSON_SIZE - padding;
        let contentMaxX = Math.max(...positions.map(p => p.x)) + PERSON_SIZE + padding + 100;
        let contentMinY = Math.min(...positions.map(p => p.y)) - PERSON_SIZE - padding;
        let contentMaxY = Math.max(...positions.map(p => p.y)) + PERSON_SIZE + padding + 50;

        const contentWidth = contentMaxX - contentMinX;
        const contentHeight = contentMaxY - contentMinY;
        const minWidth = 400;
        const minHeight = 300;

        let viewBoxX = contentMinX;
        let viewBoxY = contentMinY;
        let viewBoxWidth = contentWidth;
        let viewBoxHeight = contentHeight;

        if (contentWidth < minWidth) {
            viewBoxWidth = minWidth;
            viewBoxX = contentMinX - (minWidth - contentWidth) / 2;
        }
        if (contentHeight < minHeight) {
            viewBoxHeight = minHeight;
            viewBoxY = contentMinY - (minHeight - contentHeight) / 2;
        }

        svg.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`);
        svg.setAttribute('height', Math.min(600, viewBoxHeight));
    }

    function renderPerson(container, person, pos) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
        g.setAttribute('class', 'fd-person');
        g.setAttribute('data-person-id', person.id);

        const halfSize = PERSON_SIZE / 2;
        const labelPosition = pos.labelPosition || 'right';
        const gender = person.gender || 'unknown';

        if (gender === 'male') {
            // Rectangle for male
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', -halfSize);
            rect.setAttribute('y', -halfSize);
            rect.setAttribute('width', PERSON_SIZE);
            rect.setAttribute('height', PERSON_SIZE);
            rect.setAttribute('class', 'fd-person-shape' + (person.primary ? ' primary' : ''));
            g.appendChild(rect);

            if (person.primary) {
                // Double outline for primary person
                const outer = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const margin = 5;
                outer.setAttribute('x', -halfSize - margin);
                outer.setAttribute('y', -halfSize - margin);
                outer.setAttribute('width', PERSON_SIZE + margin * 2);
                outer.setAttribute('height', PERSON_SIZE + margin * 2);
                outer.setAttribute('class', 'fd-person-primary-outer');
                g.insertBefore(outer, rect);
            }
        } else if (gender === 'female') {
            // Circle for female
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', halfSize);
            circle.setAttribute('class', 'fd-person-shape' + (person.primary ? ' primary' : ''));
            g.appendChild(circle);

            if (person.primary) {
                // Double outline for primary person
                const outer = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                const margin = 5;
                outer.setAttribute('cx', 0);
                outer.setAttribute('cy', 0);
                outer.setAttribute('r', halfSize + margin);
                outer.setAttribute('class', 'fd-person-primary-outer');
                g.insertBefore(outer, circle);
            }
        } else {
            // Unknown gender: rounded rectangle with "?"
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', -halfSize);
            rect.setAttribute('y', -halfSize);
            rect.setAttribute('width', PERSON_SIZE);
            rect.setAttribute('height', PERSON_SIZE);
            rect.setAttribute('rx', 15);
            rect.setAttribute('ry', 15);
            rect.setAttribute('class', 'fd-person-shape');
            g.appendChild(rect);

            const qmark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            qmark.setAttribute('x', 0);
            qmark.setAttribute('y', 0);
            qmark.setAttribute('class', 'fd-person-age');
            qmark.textContent = '?';
            g.appendChild(qmark);
        }

        // Deceased X
        if (person.deceased) {
            const deceasedG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            deceasedG.setAttribute('class', 'fd-person-deceased');

            // Shorten X lines slightly to keep age visible
            const margin = 8;
            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line1.setAttribute('x1', -halfSize + margin);
            line1.setAttribute('y1', -halfSize + margin);
            line1.setAttribute('x2', halfSize - margin);
            line1.setAttribute('y2', halfSize - margin);

            const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line2.setAttribute('x1', halfSize - margin);
            line2.setAttribute('y1', -halfSize + margin);
            line2.setAttribute('x2', -halfSize + margin);
            line2.setAttribute('y2', halfSize - margin);

            deceasedG.appendChild(line1);
            deceasedG.appendChild(line2);
            g.appendChild(deceasedG);
        }

        // Age inside shape (if available and gender is known)
        if (person.age && gender !== 'unknown') {
            const age = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            age.setAttribute('x', 0);
            age.setAttribute('y', 0);
            age.setAttribute('class', 'fd-person-age');
            age.textContent = person.age;
            g.appendChild(age);
        }

        // Name label - positioned based on labelPosition
        const name = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        const idLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');

        if (labelPosition === 'above-right') {
            // Nestled in top-right corner, above the person
            name.setAttribute('x', halfSize + 2);
            name.setAttribute('y', -(halfSize + 8));
            name.setAttribute('text-anchor', 'start');
            idLabel.setAttribute('x', halfSize + 2);
            idLabel.setAttribute('y', -(halfSize + 22));
            idLabel.setAttribute('text-anchor', 'start');
        } else if (labelPosition === 'above-left') {
            // Nestled in top-left corner, above the person
            name.setAttribute('x', -(halfSize + 2));
            name.setAttribute('y', -(halfSize + 8));
            name.setAttribute('text-anchor', 'end');
            idLabel.setAttribute('x', -(halfSize + 2));
            idLabel.setAttribute('y', -(halfSize + 22));
            idLabel.setAttribute('text-anchor', 'end');
        } else if (labelPosition === 'left') {
            // To the left of the person
            name.setAttribute('x', -(halfSize + NAME_OFFSET));
            name.setAttribute('y', -halfSize + 12);
            name.setAttribute('text-anchor', 'end');
            idLabel.setAttribute('x', -(halfSize + NAME_OFFSET));
            idLabel.setAttribute('y', -halfSize + 26);
            idLabel.setAttribute('text-anchor', 'end');
        } else {
            // Default: to the right of the person
            name.setAttribute('x', halfSize + NAME_OFFSET);
            name.setAttribute('y', -halfSize + 12);
            idLabel.setAttribute('x', halfSize + NAME_OFFSET);
            idLabel.setAttribute('y', -halfSize + 26);
        }

        name.setAttribute('class', 'fd-person-name');
        name.textContent = person.name || `Person ${person.id}`;
        g.appendChild(name);

        // ID label (for debugging/development)
        idLabel.setAttribute('class', 'fd-person-name');
        idLabel.setAttribute('style', 'font-size: 10px; fill: var(--color-fg-muted);');
        idLabel.textContent = `ID: ${person.id}`;
        g.appendChild(idLabel);

        container.appendChild(g);
    }

    function renderPairBond(container, pairBond, personA, personB, layout) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'fd-pair-bond-group');
        g.setAttribute('data-pair-bond-id', pairBond.id);

        // Get pair bond bar from layout
        const pbLayout = layout.pairBonds[pairBond.id];
        const coupleX1 = pbLayout ? pbLayout.coupleX1 : Math.min(personA.x, personB.x);
        const coupleX2 = pbLayout ? pbLayout.coupleX2 : Math.max(personA.x, personB.x);
        const barY = pbLayout ? pbLayout.y : Math.max(personA.y, personB.y) + PERSON_SIZE / 2 + PAIR_BOND_DROP;

        // Draw U-shape connecting the couple, with optional extensions for children
        const aBottom = personA.y + PERSON_SIZE / 2;
        const bBottom = personB.y + PERSON_SIZE / 2;
        const bondClass = 'fd-pair-bond' + (!pairBond.married ? ' bonded' : '');

        // Vertical line from personA down to bar
        const lineA = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        lineA.setAttribute('x1', personA.x);
        lineA.setAttribute('y1', aBottom);
        lineA.setAttribute('x2', personA.x);
        lineA.setAttribute('y2', barY);
        lineA.setAttribute('class', bondClass);
        g.appendChild(lineA);

        // Vertical line from personB down to bar
        const lineB = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        lineB.setAttribute('x1', personB.x);
        lineB.setAttribute('y1', bBottom);
        lineB.setAttribute('x2', personB.x);
        lineB.setAttribute('y2', barY);
        lineB.setAttribute('class', bondClass);
        g.appendChild(lineB);

        // Horizontal bar - strictly between the couple (per spec Section 2)
        // The canopy effect comes from positioning parents further apart, not extending lines
        const coupleBar = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        coupleBar.setAttribute('x1', coupleX1);
        coupleBar.setAttribute('y1', barY);
        coupleBar.setAttribute('x2', coupleX2);
        coupleBar.setAttribute('y2', barY);
        coupleBar.setAttribute('class', bondClass);
        g.appendChild(coupleBar);

        // Separation/divorce lines (vertical, centered on the couple's horizontal bar)
        // No custody implemented yet, so lines are straight up and down
        if (pairBond.separated || pairBond.divorced) {
            const midX = (coupleX1 + coupleX2) / 2;
            const lineHeight = 15;
            const lineSpacing = 6;

            // First line (separation - single vertical line)
            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            const line1X = pairBond.divorced ? midX - lineSpacing / 2 : midX;
            line1.setAttribute('x1', line1X);
            line1.setAttribute('y1', barY + lineHeight / 2);
            line1.setAttribute('x2', line1X);
            line1.setAttribute('y2', barY - lineHeight / 2);
            line1.setAttribute('class', 'fd-separation-slash');
            g.appendChild(line1);

            // Second line (divorce only - two parallel vertical lines)
            if (pairBond.divorced) {
                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line2.setAttribute('x1', midX + lineSpacing / 2);
                line2.setAttribute('y1', barY + lineHeight / 2);
                line2.setAttribute('x2', midX + lineSpacing / 2);
                line2.setAttribute('y2', barY - lineHeight / 2);
                line2.setAttribute('class', 'fd-separation-slash');
                g.appendChild(line2);
            }
        }

        container.appendChild(g);
    }

    function renderChildConnection(container, child, pairBond) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'fd-child-connection');

        const childTop = child.y - PERSON_SIZE / 2;

        // Use ORIGINAL couple span for child attachment (not stretched span)
        // Per spec: diagonal when outside couple span, vertical when inside
        const coupleLeft = pairBond.coupleX1 !== undefined ? pairBond.coupleX1 : Math.min(pairBond.x1, pairBond.x2);
        const coupleRight = pairBond.coupleX2 !== undefined ? pairBond.coupleX2 : Math.max(pairBond.x1, pairBond.x2);

        // Determine connection point on parent bar
        let connectionX;
        if (child.x >= coupleLeft && child.x <= coupleRight) {
            // Child is within couple span - vertical line
            connectionX = child.x;
        } else if (child.x < coupleLeft) {
            // Child is left of couple - diagonal to left end
            connectionX = coupleLeft;
        } else {
            // Child is right of couple - diagonal to right end
            connectionX = coupleRight;
        }

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', child.x);
        line.setAttribute('y1', childTop);
        line.setAttribute('x2', connectionX);
        line.setAttribute('y2', pairBond.y);

        // Check if child is adopted (would need to be passed in data)
        const isAdopted = child.person && child.person.adopted;
        line.setAttribute('class', 'fd-child-line' + (isAdopted ? ' adopted' : ''));

        g.appendChild(line);
        container.appendChild(g);
    }

    // Build diagram when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', buildDiagram);
    } else {
        buildDiagram();
    }
})();
</script>
